<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLO Leaf Lesion Annotator (Enhanced)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            max-width: 95vw;
            width: 1600px;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .main-layout {
            display: flex;
            gap: 20px;
        }
        .controls-and-canvas {
            flex-grow: 1;
        }
        .sidebar {
            width: 350px;
            flex-shrink: 0;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .mode-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .mode-btn {
            padding: 10px 20px;
            border: 2px solid #007bff;
            background-color: white;
            color: #007bff;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }
        .mode-btn.active {
            background-color: #007bff;
            color: white;
        }
        .class-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .class-selector {
            padding: 8px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        .add-class-btn {
            padding: 8px 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .canvas-container {
            position: relative;
            border: 2px solid #ddd;
            display: inline-block;
            margin: 0 auto;
            text-align: center;
            overflow: hidden; /* For zoom/pan */
            width: fit-content;
        }
        #canvas {
            cursor: crosshair;
            display: block;
            background-color: #ccc;
        }
        .annotations-panel {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        .annotation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background-color: #f8f9fa;
            border-radius: 5px;
            cursor: pointer;
            border-left: 5px solid transparent;
        }
        .annotation-item.selected {
            border-left: 5px solid #007bff;
            background-color: #e7f3ff;
        }
        .delete-btn {
            padding: 5px 10px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .file-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .action-btn {
            padding: 10px 20px;
            background-color: #17a2b8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .export-btn {
            background-color: #ffc107;
            color: #212529;
        }
        .info {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
            font-size: 14px;
        }
        .drawing-tools {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üçÉ YOLO Leaf Lesion Annotator (Enhanced)</h1>
            <p>Annotate fungal lesions on leaves for YOLO detection and segmentation</p>
        </div>

        <div class="file-controls">
            <input type="file" id="imageInput" accept="image/*" class="file-input">
            <button id="loadImage" class="action-btn">Load Image</button>
            <button id="exportAnnotations" class="export-btn action-btn">Export Annotations</button>
        </div>

        <div class="main-layout">
            <div class="controls-and-canvas">
                <div class="controls">
                    <div class="mode-selector">
                        <label>Mode:</label>
                        <button class="mode-btn active" data-mode="detection">Detection (W)</button>
                        <button class="mode-btn" data-mode="segmentation">Segmentation (S)</button>
                    </div>
                    <div class="class-controls">
                        <label>Class:</label>
                        <select id="classSelector" class="class-selector">
                            <option value="fungal_lesion">Fungal Lesion</option>
                            <option value="healthy">Healthy</option>
                            <option value="diseased">Diseased</option>
                        </select>
                        <button id="addClassBtn" class="add-class-btn">Add Class</button>
                    </div>
                </div>

                <div class="canvas-container">
                    <canvas id="canvas" width="800" height="600"></canvas>
                </div>
            </div>

            <div class="sidebar">
                <div class="annotations-panel">
                    <h3>Annotations</h3>
                    <div id="annotationsList"></div>
                </div>
                <div class="info">
                    <h4>Instructions & Shortcuts:</h4>
                    <ul>
                        <li><strong>Zoom:</strong> Mouse Wheel</li>
                        <li><strong>Pan:</strong> Spacebar + Drag</li>
                        <li><strong>Edit:</strong> Click to select an annotation. Drag to move, or drag handles/points to resize.</li>
                        <li><strong>Delete:</strong> Select an annotation and press `Delete` or `Backspace`.</li>
                        <li><strong>Deselect/Cancel:</strong> Press `Esc`.</li>
                        <li><strong>Undo/Redo:</strong> `Ctrl+Z` / `Ctrl+Y`.</li>
                        <li><strong>Finish Polygon:</strong> Double-click.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- SETUP ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let currentMode = 'detection';
        let annotations = [];
        let currentImage = null;

        // --- STATE MANAGEMENT ---
        let isDrawing = false;
        let isDragging = false;
        let isPanning = false;
        let startX, startY;
        
        let selectedAnnotationIndex = -1;
        let selectedPointIndex = -1;
        let dragHandle = null; // For resizing bboxes: 'tl', 'tr', 'bl', 'br', 't', 'r', 'b', 'l'
        
        let currentPolygon = [];
        let drawingPolygon = false;

        // --- VIEWPORT (ZOOM/PAN) ---
        let zoom = 1;
        let pan = { x: 0, y: 0 };
        const ZOOM_SENSITIVITY = 0.001;
        let lastPanPoint = { x: 0, y: 0 };
        let isSpacePressed = false;
        
        // --- HISTORY (UNDO/REDO) ---
        let history = [];
        let historyIndex = -1;


        // --- CLASS MANAGEMENT ---
        const classColors = {
            'fungal_lesion': { fill: 'rgba(255, 0, 0, 0.3)', stroke: 'red' },
            'healthy': { fill: 'rgba(0, 255, 0, 0.3)', stroke: 'green' },
            'diseased': { fill: 'rgba(255, 165, 0, 0.3)', stroke: 'orange' }
        };

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', setupEventListeners);

        function setupEventListeners() {
            // UI Controls
            document.querySelectorAll('.mode-btn').forEach(btn => btn.addEventListener('click', switchMode));
            document.getElementById('loadImage').addEventListener('click', loadImage);
            document.getElementById('exportAnnotations').addEventListener('click', exportAnnotations);
            document.getElementById('addClassBtn').addEventListener('click', addCustomClass);

            // Canvas Events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('dblclick', handleDoubleClick);
            canvas.addEventListener('wheel', handleWheel);

            // Keyboard Events
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
        }

        // --- CORE FUNCTIONS ---

        function loadImage() {
            const fileInput = document.getElementById('imageInput');
            if (!fileInput.files[0]) {
                alert('Please select an image file');
                return;
            }
            const reader = new FileReader();
            reader.onload = e => {
                currentImage = new Image();
                currentImage.onload = () => {
                    const maxWidth = 1200;
                    const aspect = currentImage.width / currentImage.height;
                    canvas.width = Math.min(currentImage.width, maxWidth);
                    canvas.height = canvas.width / aspect;
                    resetState();
                    redrawCanvas();
                };
                currentImage.src = e.target.result;
            };
            reader.readAsDataURL(fileInput.files[0]);
        }

        function switchMode(e) {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const btn = e.target;
            btn.classList.add('active');
            currentMode = btn.dataset.mode;
            deselectAnnotation();
            redrawCanvas();
        }
        
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(pan.x, pan.y);
            ctx.scale(zoom, zoom);

            if (currentImage) {
                ctx.drawImage(currentImage, 0, 0, currentImage.width, currentImage.height);
            }

            annotations.forEach((ann, index) => drawAnnotation(ann, index));

            if (drawingPolygon && currentPolygon.length > 0) {
                drawPolygon(currentPolygon, 'rgba(0, 0, 255, 0.3)', 'blue', true);
            }
            
            ctx.restore();
        }

        function drawAnnotation(ann, index) {
            const isSelected = index === selectedAnnotationIndex;
            const colors = classColors[ann.class] || { fill: 'rgba(128,128,128,0.3)', stroke: 'gray' };
            ctx.fillStyle = colors.fill;
            ctx.strokeStyle = colors.stroke;
            ctx.lineWidth = isSelected ? 3 / zoom : 2 / zoom;

            if (ann.type === 'bbox') {
                ctx.fillRect(ann.x, ann.y, ann.width, ann.height);
                ctx.strokeRect(ann.x, ann.y, ann.width, ann.height);
                if (isSelected) drawHandles(ann);
            } else if (ann.type === 'polygon') {
                ctx.beginPath();
                ctx.moveTo(ann.points[0].x, ann.points[0].y);
                for (let i = 1; i < ann.points.length; i++) {
                    ctx.lineTo(ann.points[i].x, ann.points[i].y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                if (isSelected) drawPolygonPoints(ann.points);
            }
            
            // Draw label
            const labelX = ann.type === 'bbox' ? ann.x : ann.points[0].x;
            const labelY = ann.type === 'bbox' ? ann.y : ann.points[0].y;
            ctx.fillStyle = colors.stroke;
            ctx.font = `${14 / zoom}px Arial`;
            ctx.fillText(ann.class, labelX, labelY - (5 / zoom));
        }
        
        function drawPolygon(points, fillStyle, strokeStyle, isDashed = false) {
            ctx.fillStyle = fillStyle;
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 2 / zoom;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            if (isDashed) {
                 ctx.setLineDash([5 / zoom, 5 / zoom]);
                 ctx.stroke();
                 ctx.setLineDash([]);
            } else {
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawPolygonPoints(points);
        }

        function drawHandles(bbox) {
            const handleSize = 8 / zoom;
            const handles = getHandles(bbox);
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1 / zoom;
            for (const key in handles) {
                const handle = handles[key];
                ctx.fillRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
                ctx.strokeRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
            }
        }
        
        function drawPolygonPoints(points) {
            const pointSize = 6 / zoom;
            points.forEach(p => {
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 1 / zoom;
                ctx.fillRect(p.x - pointSize / 2, p.y - pointSize / 2, pointSize, pointSize);
                ctx.strokeRect(p.x - pointSize / 2, p.y - pointSize / 2, pointSize, pointSize);
            });
        }


        // --- EVENT HANDLERS ---

        function handleMouseDown(e) {
            e.preventDefault();
            const mousePos = getMousePos(e);

            if (isSpacePressed) {
                isPanning = true;
                lastPanPoint = { x: e.clientX, y: e.clientY };
                return;
            }
            
            // Check for interaction with existing annotations
            const hit = hitTest(mousePos);
            if (hit) {
                selectedAnnotationIndex = hit.annIndex;
                selectedPointIndex = hit.pointIndex ?? -1;
                isDragging = true;
                dragHandle = hit.handle || null;
                startX = mousePos.x;
                startY = mousePos.y;
                updateAnnotationsList();
                redrawCanvas();
                return;
            }
            
            deselectAnnotation();

            if (currentMode === 'detection') {
                isDrawing = true;
                startX = mousePos.x;
                startY = mousePos.y;
            } else if (currentMode === 'segmentation') {
                drawingPolygon = true;
                currentPolygon.push(mousePos);
                redrawCanvas();
            }
        }

        function handleMouseMove(e) {
            e.preventDefault();
            const mousePos = getMousePos(e);

            if (isPanning) {
                pan.x += e.clientX - lastPanPoint.x;
                pan.y += e.clientY - lastPanPoint.y;
                lastPanPoint = { x: e.clientX, y: e.clientY };
                redrawCanvas();
                return;
            }
            
            updateCursor(mousePos);

            if (isDragging && selectedAnnotationIndex !== -1) {
                const dx = mousePos.x - startX;
                const dy = mousePos.y - startY;
                const ann = annotations[selectedAnnotationIndex];
                
                if (ann.type === 'bbox') {
                    if (dragHandle) { // Resizing
                        const { x, y, width, height } = ann;
                        if (dragHandle.includes('l')) { ann.x += dx; ann.width -= dx; }
                        if (dragHandle.includes('r')) { ann.width += dx; }
                        if (dragHandle.includes('t')) { ann.y += dy; ann.height -= dy; }
                        if (dragHandle.includes('b')) { ann.height += dy; }
                    } else { // Moving
                        ann.x += dx;
                        ann.y += dy;
                    }
                } else if (ann.type === 'polygon') {
                    if (selectedPointIndex !== -1) { // Moving a point
                        ann.points[selectedPointIndex].x += dx;
                        ann.points[selectedPointIndex].y += dy;
                    } else { // Moving whole polygon
                        ann.points.forEach(p => { p.x += dx; p.y += dy; });
                    }
                }
                
                startX = mousePos.x;
                startY = mousePos.y;
                redrawCanvas();
            } else if (isDrawing && currentMode === 'detection') {
                redrawCanvas();
                ctx.save();
                ctx.translate(pan.x, pan.y);
                ctx.scale(zoom, zoom);
                ctx.fillStyle = classColors[document.getElementById('classSelector').value].fill;
                ctx.strokeStyle = classColors[document.getElementById('classSelector').value].stroke;
                ctx.lineWidth = 2 / zoom;
                ctx.fillRect(startX, startY, mousePos.x - startX, mousePos.y - startY);
                ctx.strokeRect(startX, startY, mousePos.x - startX, mousePos.y - startY);
                ctx.restore();
            }
        }

        function handleMouseUp(e) {
            e.preventDefault();

            if (isPanning) {
                isPanning = false;
                return;
            }
            
            if (isDragging) {
                const ann = annotations[selectedAnnotationIndex];
                if (ann.type === 'bbox' && (ann.width < 0 || ann.height < 0)) {
                    // Normalize box if resized negatively
                    if (ann.width < 0) { ann.x += ann.width; ann.width *= -1; }
                    if (ann.height < 0) { ann.y += ann.height; ann.height *= -1; }
                }
                saveState();
                isDragging = false;
                dragHandle = null;
                selectedPointIndex = -1;
            }

            if (isDrawing && currentMode === 'detection') {
                isDrawing = false;
                const mousePos = getMousePos(e);
                const width = mousePos.x - startX;
                const height = mousePos.y - startY;

                if (Math.abs(width) > 5 && Math.abs(height) > 5) {
                    addAnnotation({
                        type: 'bbox',
                        class: document.getElementById('classSelector').value,
                        x: Math.min(startX, mousePos.x),
                        y: Math.min(startY, mousePos.y),
                        width: Math.abs(width),
                        height: Math.abs(height)
                    });
                }
                redrawCanvas();
            }
        }
        
        function handleDoubleClick(e) {
            if (currentMode === 'segmentation' && drawingPolygon && currentPolygon.length >= 3) {
                finishPolygon();
            }
        }
        
        function handleWheel(e) {
            e.preventDefault();
            const mousePos = getMousePos(e, true); // Get raw mouse pos
            const zoomAmount = e.deltaY * ZOOM_SENSITIVITY;
            const newZoom = Math.max(0.1, Math.min(20, zoom * (1 - zoomAmount)));

            // Adjust pan to zoom towards the cursor
            pan.x = mousePos.x - (mousePos.x - pan.x) * (newZoom / zoom);
            pan.y = mousePos.y - (mousePos.y - pan.y) * (newZoom / zoom);
            
            zoom = newZoom;
            redrawCanvas();
        }

        function handleKeyDown(e) {
            if (e.key === ' ' && !isPanning) {
                isSpacePressed = true;
                canvas.style.cursor = 'grab';
            }
            
            if (e.key === 'Escape') {
                if (drawingPolygon) cancelPolygon();
                else deselectAnnotation();
            }
            
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if(selectedAnnotationIndex !== -1) {
                    deleteAnnotation(selectedAnnotationIndex);
                }
            }

            if (e.ctrlKey) {
                if (e.key === 'z') undo();
                if (e.key === 'y') redo();
            }

            if (e.key.toLowerCase() === 'w') document.querySelector('[data-mode="detection"]').click();
            if (e.key.toLowerCase() === 's') document.querySelector('[data-mode="segmentation"]').click();
        }
        
        function handleKeyUp(e) {
            if (e.key === ' ') {
                isSpacePressed = false;
                isPanning = false;
                updateCursor(getMousePos(e));
            }
        }


        // --- ANNOTATION & UI LOGIC ---

        function addAnnotation(ann) {
            annotations.push(ann);
            saveState();
            updateAnnotationsList();
        }

        function deleteAnnotation(index) {
            if (index < 0 || index >= annotations.length) return;
            annotations.splice(index, 1);
            deselectAnnotation();
            saveState();
            updateAnnotationsList();
            redrawCanvas();
        }

        function finishPolygon() {
            if (currentPolygon.length >= 3) {
                addAnnotation({
                    type: 'polygon',
                    class: document.getElementById('classSelector').value,
                    points: [...currentPolygon]
                });
            }
            cancelPolygon();
        }

        function cancelPolygon() {
            currentPolygon = [];
            drawingPolygon = false;
            redrawCanvas();
        }

        function updateAnnotationsList() {
            const list = document.getElementById('annotationsList');
            list.innerHTML = '';
            
            annotations.forEach((ann, index) => {
                const item = document.createElement('div');
                item.className = 'annotation-item';
                if (index === selectedAnnotationIndex) {
                    item.classList.add('selected');
                }
                
                item.addEventListener('click', () => {
                    selectedAnnotationIndex = index;
                    updateAnnotationsList();
                    redrawCanvas();
                });
                
                let info = (ann.type === 'bbox')
                    ? `${ann.class} - BBox`
                    : `${ann.class} - Polygon (${ann.points.length} points)`;
                
                item.innerHTML = `
                    <span>${index + 1}: ${info}</span>
                    <button class="delete-btn" onclick="confirmDelete(${index})">Delete</button>
                `;
                list.appendChild(item);
            });
        }
        window.confirmDelete = (index) => {
            if(confirm('Are you sure you want to delete this annotation?')) {
                deleteAnnotation(index);
            }
        };

        function addCustomClass() {
            const className = prompt('Enter new class name:');
            if (!className || !className.trim()) return;
            
            const selector = document.getElementById('classSelector');
            const value = className.toLowerCase().replace(/\s+/g, '_');
            
            if (classColors[value]) {
                alert('Class already exists.');
                return;
            }

            const option = document.createElement('option');
            option.value = value;
            option.textContent = className;
            selector.appendChild(option);
            selector.value = value;
            
            classColors[value] = { 
                fill: `rgba(${Math.random()*200|0}, ${Math.random()*200|0}, ${Math.random()*200|0}, 0.3)`,
                stroke: `rgb(${Math.random()*200|0}, ${Math.random()*200|0}, ${Math.random()*200|0})`
            };
        }


        // --- HELPERS & STATE ---
        
        function getMousePos(e, raw = false) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (raw) return { x, y };
            return {
                x: (x - pan.x) / zoom,
                y: (y - pan.y) / zoom
            };
        }

        function hitTest(pos) {
            const tolerance = 8 / zoom;
            for (let i = annotations.length - 1; i >= 0; i--) {
                const ann = annotations[i];
                if (ann.type === 'bbox') {
                    // Check handles first
                    const handles = getHandles(ann);
                    for (const key in handles) {
                        const handle = handles[key];
                        if (Math.abs(pos.x - handle.x) < tolerance && Math.abs(pos.y - handle.y) < tolerance) {
                            return { annIndex: i, handle: key };
                        }
                    }
                    // Check inside box
                    if (pos.x >= ann.x && pos.x <= ann.x + ann.width && pos.y >= ann.y && pos.y <= ann.y + ann.height) {
                        return { annIndex: i };
                    }
                } else if (ann.type === 'polygon') {
                    // Check points
                    for (let j = 0; j < ann.points.length; j++) {
                        const p = ann.points[j];
                        if (Math.sqrt((pos.x - p.x)**2 + (pos.y - p.y)**2) < tolerance) {
                            return { annIndex: i, pointIndex: j };
                        }
                    }
                    // Check inside polygon (ray-casting)
                    if (isPointInPolygon(pos, ann.points)) {
                        return { annIndex: i };
                    }
                }
            }
            return null;
        }

        function getHandles(bbox) {
            const { x, y, width, height } = bbox;
            return {
                tl: { x: x, y: y }, tr: { x: x + width, y: y },
                bl: { x: x, y: y + height }, br: { x: x + width, y: y + height },
                t: { x: x + width / 2, y: y }, b: { x: x + width / 2, y: y + height },
                l: { x: x, y: y + height / 2 }, r: { x: x + width, y: y + height / 2 }
            };
        }
        
        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                const intersect = ((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function updateCursor(mousePos) {
            if (isSpacePressed) { canvas.style.cursor = 'grab'; return; }
            if (isDragging) { canvas.style.cursor = 'grabbing'; return; }

            const hit = hitTest(mousePos);
            if (hit) {
                if (hit.handle) {
                    if (hit.handle === 'tl' || hit.handle === 'br') canvas.style.cursor = 'nwse-resize';
                    else if (hit.handle === 'tr' || hit.handle === 'bl') canvas.style.cursor = 'nesw-resize';
                    else if (hit.handle === 't' || hit.handle === 'b') canvas.style.cursor = 'ns-resize';
                    else if (hit.handle === 'l' || hit.handle === 'r') canvas.style.cursor = 'ew-resize';
                } else if (hit.pointIndex !== undefined) {
                    canvas.style.cursor = 'move';
                } else {
                    canvas.style.cursor = 'move';
                }
            } else {
                canvas.style.cursor = 'crosshair';
            }
        }
        
        function deselectAnnotation() {
            selectedAnnotationIndex = -1;
            selectedPointIndex = -1;
            isDragging = false;
            updateAnnotationsList();
            redrawCanvas();
        }

        function resetState() {
            annotations = [];
            currentPolygon = [];
            drawingPolygon = false;
            isDrawing = false;
            zoom = 1;
            pan = { x: 0, y: 0 };
            deselectAnnotation();
            history = [];
            historyIndex = -1;
            saveState(); // Initial empty state
            updateAnnotationsList();
        }

        // --- HISTORY MANAGEMENT ---
        function saveState() {
            // Clear future states when a new action is taken
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            // Use JSON stringify/parse for a deep copy
            history.push(JSON.parse(JSON.stringify(annotations)));
            historyIndex++;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                annotations = JSON.parse(JSON.stringify(history[historyIndex]));
                deselectAnnotation();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                annotations = JSON.parse(JSON.stringify(history[historyIndex]));
                deselectAnnotation();
            }
        }


        // --- EXPORT ---
        function exportAnnotations() {
            if (annotations.length === 0) {
                alert('No annotations to export');
                return;
            }
            if (!currentImage) {
                alert('Load an image before exporting');
                return;
            }

            const classes = [...new Set(annotations.map(ann => ann.class))];
            const classMap = Object.fromEntries(classes.map((cls, idx) => [cls, idx]));
            
            let yoloData = '';
            
            annotations.forEach(ann => {
                const classIndex = classMap[ann.class];
                if (ann.type === 'bbox') {
                    const x_center = (ann.x + ann.width / 2) / currentImage.width;
                    const y_center = (ann.y + ann.height / 2) / currentImage.height;
                    const width = ann.width / currentImage.width;
                    const height = ann.height / currentImage.height;
                    yoloData += `${classIndex} ${x_center.toFixed(6)} ${y_center.toFixed(6)} ${width.toFixed(6)} ${height.toFixed(6)}\n`;
                } else if (ann.type === 'polygon') {
                    const pointsStr = ann.points.map(p => 
                        `${(p.x / currentImage.width).toFixed(6)} ${(p.y / currentImage.height).toFixed(6)}`
                    ).join(' ');
                    yoloData += `${classIndex} ${pointsStr}\n`;
                }
            });

            const fileName = document.getElementById('imageInput').files[0]?.name.split('.')[0] || 'annotations';
            downloadFile(`${fileName}.txt`, yoloData);
            downloadFile(`classes.txt`, classes.join('\n'));
            
            alert('Annotations exported successfully!');
        }

        function downloadFile(filename, content) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([content], { type: 'text/plain' }));
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

    </script>
</body>
</html>